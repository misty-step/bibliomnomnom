The `/docs` directory serves as the centralized technical and operational knowledge base for the bibliomnomnom project. It documents a serverless, real-time architecture built on **Convex** (backend), **Next.js** (frontend), and **Bun** (package management), with external integrations for **Clerk** (auth), **Stripe** (billing), and **OpenRouter** (LLM services). The documentation is structured to bridge high-level product strategy with low-level implementation details, covering architecture decision records (ADRs), deployment protocols, brand standards, and incident reports.

### Architecture and Design Patterns

The system utilizes a serverless-first architecture optimized for resilience and data integrity:

- **State Machine Logic:** Complex asynchronous workflows, particularly the "Listening Sessions" (audio recording → upload → transcription → synthesis), are managed via server-side state machines to maintain consistency across client disconnects.
- **Action/Mutation Split:** Non-deterministic side effects, such as LLM calls and third-party API interactions, are isolated in Convex Actions. Validated data is then passed to Mutations for atomic persistence.
- **Repository Pattern:** An abstraction layer decouples business logic from the Convex database, facilitating unit testing through in-memory mocks.
- **Observability Stack:** Monitoring is handled via a multi-layered approach: **Sentry** for error tracking (with PII scrubbing), **PostHog** for analytics, and **Pino** for structured JSON logging. A specialized `/api/health` endpoint provides shallow and deep probes into downstream services (Convex, Clerk, Stripe).

### Key File Roles and Subdirectories

- **`PRODUCT-PRIORITIES.md`**: The authoritative roadmap, aligning technical epics (Core Tracking, Voice Notes, Profile Intelligence) with specific GitHub issues and outcome-based pillars.
- **`OBSERVABILITY.md`**: Defines the logging strategy and provides a CLI-based toolkit (`./scripts/obs`) for managing Sentry issues and environment-specific health checks.
- **ADRs (Architecture Decision Records)**: Document foundational choices, including the dual-provisioning auth flow, the five-state subscription model, and the "earliest-wins" de-duplication pattern for database inserts.
- **`/flows`**: Contains Mermaid diagrams and state definitions for high-complexity operations like CSV/Markdown imports, OCR-based quote capture, and the Stripe payment lifecycle.
- **`/performance`**: Houses the Speech-to-Text (STT) decision matrix and benchmarking scripts used to evaluate providers (ElevenLabs vs. Deepgram) based on Word Error Rate (WER) and cost.
- **`/deployment` & `/investigations`**: Govern the operational lifecycle, documenting pre-production checklists, environment variable management, and root cause analyses for production incidents.
- **`/brand`**: Technical specifications for the UI, including design tokens, functional color systems (Canvas/Ink/Gold), and typographic stacks (Playfair Display/Geist/JetBrains Mono).

### Important Dependencies and Gotchas

- **Convex Environment Context:** A recurring technical pitfall involves the Convex CLI; it may default to development data unless the `--prod` flag is explicitly used, even if environment variables are set.
- **Environment Variable Integrity:** The system is highly sensitive to the formatting of secrets (e.g., `CONVEX_WEBHOOK_TOKEN`). Trailing newlines (`\n`) introduced during Vercel/Convex dashboard entry can cause silent authentication failures or "Invalid character in header" errors.
- **Webhook Synchronization:** Reliable operation depends on a three-way handshake between Stripe, Vercel, and Convex. Any drift in the shared webhook token or the endpoint URL across these platforms will break the subscription synchronization pipeline.
- **Vercel Blob Privacy:** Because Vercel Blob storage lacks per-file private access, the architecture requires an auth-gated proxy and server-side upload strategy to protect user audio data.
- **Unique Constraints:** Convex does not natively enforce unique constraints, necessitating the manual de-duplication logic and idempotency checks documented in the reliability ADRs.
