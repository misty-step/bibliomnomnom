This directory contains the test suite for book-related UI components, focusing on the integration between frontend interactions and backend actions for book management and metadata enrichment. The tests are built using Vitest and React Testing Library, employing a mocking strategy to isolate components from the Convex backend and Vercel Blob storage.

### Architecture and Key File Roles

The testing architecture centers on validating asynchronous workflows and state transitions triggered by user actions.

- **`AddBookSheet.backfill.test.tsx`**: This file validates the integration between book creation and the automated cover retrieval system. It specifically tests the side effect where, upon successful execution of the `createBook` mutation, the component triggers the `fetchMissingCovers` action for the newly created record if no cover image was provided by the user.
- **`FetchMissingCoversButton.test.tsx`**: This file tests the pagination logic and state management of the bulk cover update process. It ensures the component correctly handles cursors returned by the backend, recursively calling the fetch action until the `nextCursor` is null, and provides appropriate feedback via toast notifications based on the aggregated results (e.g., success counts vs. failures).

### Key Dependencies

- **Vitest & React Testing Library**: Serve as the core testing framework and utility library for DOM assertion.
- **Convex React Hooks**: `useMutation` and `useAction` are mocked globally within these tests to intercept backend calls and return controlled promises, allowing for the simulation of network latency and specific API response shapes.
- **Vercel Blob**: The `@vercel/blob/client` library is mocked to prevent actual network egress during tests that involve file upload logic.
- **Shadcn UI / Toast**: The `@/hooks/use-toast` hook is mocked to verify that the UI correctly communicates the outcome of background processes to the user.

### Important Gotchas

- **Positional Input Selection**: In `AddBookSheet.backfill.test.tsx`, inputs are targeted via their index in the DOM (`querySelectorAll`). This creates a structural dependency where changes to the form layout or the addition of new fields (like a search bar) can break the test selectors.
- **Action Chaining**: The tests rely on the manual resolution of promises to simulate the sequence of a mutation followed by an action. Ensuring that the `createBook` mock resolves with a valid ID is critical for the subsequent `fetchMissingCovers` call to receive the correct arguments.
- **Recursive Mocking**: The `FetchMissingCoversButton` tests utilize `mockResolvedValueOnce` to simulate a multi-page paginated response, requiring precise alignment between the mocked cursor values and the component's loop logic.
