This directory implements a Repository Pattern to abstract data access for the application's book import system. By decoupling the data persistence logic from the business logic, the architecture supports multiple storage backends, specifically targeting Convex as the primary production database and an in-memory implementation for testing and local development.

### Architecture and Key Roles

The directory is structured around three core entities: **Books**, **ImportRuns** (tracking the status and metadata of an import process), and **ImportPreviews** (storing transient, paginated data for user review before finalization).

- **`interfaces.ts`**: Defines the contract for the repository layer. It establishes three primary interfaces—`BookRepository`, `ImportRunRepository`, and `ImportPreviewRepository`—ensuring consistent method signatures across different implementations. These interfaces utilize TypeScript types generated by Convex to maintain strict schema adherence.
- **`convex.ts`**: Provides the production implementation. It utilizes a `Db` type (a specialized pick of Convex’s `DatabaseReader` and `DatabaseWriter`) to perform operations. This implementation relies heavily on Convex-defined indexes (e.g., `by_user_run_page`) to perform efficient queries within the server-side runtime. A `createConvexRepositories` factory function is exported to instantiate the full suite of repositories.
- **`memory.ts`**: Provides an in-memory implementation using JavaScript `Map` objects. This is designed for high-speed unit testing and environments where a live Convex instance is unavailable. It includes additional lifecycle methods like `seed()` and `clear()` for state management between tests. It mimics database indexing by using composite keys (e.g., `userId|runId|page`) for lookups.

### Dependencies and Key Details

- **Convex Integration**: The directory is tightly coupled with the `@/convex/_generated/` directory. Even the abstract interfaces rely on `Doc` and `Id` types generated from the Convex schema to ensure that data structures remain synchronized with the database.
- **ID Simulation**: In `memory.ts`, unique identifiers are generated using a simple counter and cast to the `Id<T>` type. While this satisfies the TypeScript compiler, these IDs do not follow the internal format of actual Convex IDs.
- **Index Dependency**: The `ConvexBookRepository` and its siblings depend on specific index names being defined in the Convex schema (`by_user`, `by_user_run`, etc.). If these indexes are missing or renamed in the schema configuration, the query methods in `convex.ts` will fail at runtime.
- **Temporal Logic**: The `findRecentByUser` method in the `ImportRunRepository` implementations handles time-based filtering differently: the Convex version relies on a `createdAt` field, while the memory version uses a fallback to `_creationTime` (a Convex-internal metadata field) or a manual timestamp.
